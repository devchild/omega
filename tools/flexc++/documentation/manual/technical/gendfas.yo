The function tt(Generator::dfas), defined in tt(generator/dfas) defines
defines in tt(d_out) the static data member tt(int const
ScannerBase::s_dfa[][dfaCols()]), where tt(dfaCols) returns the number of
columns of the DFA matrices.

em(All) DFAs are accessed through this single tt(s_dfa) matrix. Each
individual DFA starts at a specific row of tt(s_dfa). The first DFA to be
written is associated with the tt(INITIAL) scanner: tt(INITIAL) is always
defined and contains all rules not explicitly associated with a start condition.

The matrix tt(s_dfa) contains the rows of em(all) DFAs, including those that
were generated by flc() itself, with the start state tt(INITIAL) always
being the first DFA.

Each row contains the row to transit to if the column's character range was
sensed. Row numbers are relative to the used DFA. There are as many elements
in the rows of the tt(s_dfa) table as there are character ranges em(plus)
two. These final elements represent rule indices of, respectively, the matched
rule (normal case) and the matched rule in case of BOL. The value -1 is used
if no such rule is associated with the DFA row.

The em(base locations) for the various start conditions are defined in the
static array tt(s_dfaBase). Its initial value matches the tt(INITIAL) scanner,
and points to the first tt(s_dfa) row. Additional values are defined for each
additional start condition, and point to the initial rows in tt(s_dfa) for
these start conditions. Here is an example of a tt(enum class Begin) and
matching tt(s_dfaBase):
        verb(
    enum class Begin
    {
        INITIAL,
        str,
    };
        
    std::vector<int const (*)[9]> const ScannerBase::s_dfaBase =
    {
        { s_dfa + 0 },
        { s_dfa + 6 },
    };
        )
    The tt(INITIAL) scanner's dfa rows start at the top, the tt(str) mini
scanner starts at row index 6 of tt(s_dfa).
    
