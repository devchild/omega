This file describes the lookahead-propagation procedure as used by Bisonc++
A more extensive description is found in documentation/manual/algorithm.yo

Start with the following simple grammar:

    1   run$:   run
    
    2   run:    one
    3   run:    two X
    
    4   one:  

    5   two:    one

This grammar produces the following states:

    S0:     run$:   .   run     (kernel)    

            run:    .   one     (non-kernel)
            run:    .   two X

            one:    .   
            two:    .   one
    

    S1:     run$:   run .       (accept)


    S2:     run:    one .       (kernel)
            two:    one .


    S3:     run:    two .   X   (kernel)


    S4:     run:    two X   .   (kernel)

Notation: 
    The notation FIRST(d L) indicates the FIRST set of the sequence `d L'. The
    notation {} is used to indicate the empty set. Otherwise, the terminals
    are shown in a blank-delimited list, e.g., {X $}

Within an item, its non-kernel items are inspected to obtain the
lookaheads. The lookaheads are propagated, starting from the 
initial $, representing EOF. 

With a particular item (L being its LA set):

            a:  b . C d, L

all rules of C must be added to the item as non-kernel items. These items 
use LA FIRST(d, L). When transiting to the next state, an item in a new state
inherits it LA set of its `parent'

The initial set receives LA {$}. So:

    S0: 1   run$:   .   run, {$}

In this set, the `run' rules must be added, receiving LA FIRST({} $) = {$}. 
So, the `run' rules become:

        2   run:    .   one     , {$}
        3   run:    .   two X   , {$}

From (2) the `one' rule is added, using LA FIRST({}, $) = $.

        4   one:    .           , {$}

From (3) the `two' rule is aded, receiving LA FIRST(X $) = X

        5   two:    .   one     , {X}

From (5) the `one' rules are once again added, receiving LA FIRST({}, X) = X

        4   one:    .           , {X $}     (revised)
    

    This results in:

    S0: 1   run$:   .   run, {$}
        2   run:    .   one     , {$}
        3   run:    .   two X   , {$}
        4   one:    .           , {X $}
        5   two:    .   one     , {X}

        Transitions on: 
            run -> S1
            one -> S2
            two -> S3

        There is one reduction in this state (4), so it becomes the default
        reduction. A default reduction is executed immediately upon entering
        its state:

        Reduce: according to rule 4 (by default)


   Transition on run, inheriting the LA set:

    S1: 1   run$:   run .   {$} 

        There is one reduction in this state (4), so it becomes the default
        reduction. 
    
        Reduce: according to rule 1 (by default)


   Transition on one, inheriting the LA sets:

    S2: 2   run:    one .   , {$}
        5   two:    one .   , {X}

        There are two reductions in this state (2, 5). There is no conflict as
        they have different LA sets. So:

        Reduce on:
            $:  according to rule 2
            X:  according to rule 5

            (Optionally, define one as the default reduction).

   Transition on two, inheriting the LA set:

    S3: 3   run:    two .   X   , {$}

        Transition on
            X -> S4, LA remains unaltered:


    S4: 3   run:    two X   .   , {$}

        Reduce: according to rule 3 (by default)

==========================================================================

Now consider the following grammar, after Aho, example 4.46:

    Here's the grammar:

        1.  S*: S
        2.  S:  L = R
        3.  S:  R
        4.  L:  * R
        5.  L:  i
        6.  R:  L

Here are the states:

    S0: 1.  S*: . S
    
    S1: 1.  S*: S .
    
    S2: 2.  S:  L . = R
        6.  R:  L .
    
    S3: 3.  S:  R .
    
    S4: 4.  L:  * . R
    
    S5: 5.  L:  i .
    
    S6: 2.  S:  L = . R
        
    S7: 4.  L:  * R .
    
    S8: 6.  R:  L .
    
    S9: 2.  S:  L = R .


Start at state S0, LA {$}:


S0: 1.  S*: . S ,   {$}

    Adding the `S' rules, same LA, we get:
        2.  S:  .   L = R   {$}
        3.  S:  .   R       {$}

    Adding the `L' rules from (2), LA {=} is used:
        4.  L:  .   * R     {=}
        5.  L:  .   i       {=}

    Adding the `R' rule from (3), LA {$} is kept:
        6.  R:  .   L       {$}

    Revising the L rules from (6), LA {$} is added:
        4.  L:  .   * R     {= $}       (revised)
        5.  L:  .   i       {= $}       (revised)

    This results in:
        S0: 1.  S*: . S ,   {$}
            2.  S:  .   L = R   {$}
            3.  S:  .   R       {$}
            4.  L:  .   * R     {= $}     
            5.  L:  .   i       {= $}     
            6.  R:  .   L       {$}

    Transitions on: 
        S   -> S1
        L   -> S2
        R   -> S3
        *   -> S4
        i   -> S5

   Transition on S, inheriting the LA set:
        S1: 1.  S*: S . {$}     (accept)

   Transition on L, inheriting the LA set:
        S2: 2.  S:  L . = R     {$)     (LA inherited from 2)
            6.  R:  L .         ($)     (LA inherited from 6)

   Transition on R, inheriting the LA set:
        S3: 3.  S:  R .         {$}

   Transition on *, inheriting the LA set:
        S4: 4.  L:  * . R       {= $}

    Transition on i, inheriting the LA set:
        S5: 5.  L:  i .         {= $}


S1: 1.  S*: S . {$}     (accept)

    Reduce: according to rule 1 (by default)


S2: 2.  S:  L . = R     {$)
    6.  R:  L .         ($)

    Transition on:
        =   -> S6

    Reduce: according to (6) by default.

    Transition on =, inheriting the LA set:
        S6: 2.  S:  L = . R     {$)     (LA inherited from 2)


S3: 3.  S:  R .         {$}

    Reduce: according to rule 3 (by default)

     
S4: 4.  L:  * . R       {= $}

    Adding the R rules, LA unaltered:
        6.  R:  .   L       {= $}

    Adding the L rules from (6), LA unaltered:
        4.  L:  .   * R     {= $}
        5.  L:  .   i       {= $}

    This results in:
        S4: 4.  L:  * . R       {= $}
            6.  R:  .   L       {= $}
            4.  L:  .   * R     {= $}
            5.  L:  .   i       {= $}

    Transition on:
        R   -> S7
        L   -> S8
        *   -> S4
        i   -> S5

    Transition on  R, inheriting LA {= $}
        S7: 4.  L:  * R .   {$ =}

    Transition on  L, inheriting LA {= $}
        S8: 6.  R:  L . {= $}

   Transition on *, inheriting the LA set:
        S4: 4.  L:  * . R       {= $} 
        LA set at 4 already {= $}. No need to change. Done.


    Transition on i, inheriting the LA set:
        S5: 5.  L:  i .         {= $}
        LA set at 5 already {= $}. No need to change. Done.

        
S5: 5.  L:  i .             {= $}
    
    Reduce: according to rule 5 (by default)


S6: 2.  S:  L = . R     {$)

    Adding the R rules, LA unaltered:
        6.  R:  .   L       {$}

    Adding the L rules from (6), LA unaltered:
        4.  L:  .   * R     {$}
        5.  L:  .   i       {$}

    This results in:
        2.  S:  L = R .     {$}
        6.  R:  .   L       {$}
        4.  L:  .   * R     {$}
        5.  L:  .   i       {$}

    Transition on:
        R   -> S9
        L   -> S8
        *   -> S4
        i   -> S5

    Transition on  R, inheriting LA {= $}
        S9: 2.  S:  L = R . {$}
      
    Transition on  L, inheriting LA {= $}
        S8: 6.  R:  L . {$}
        LA set at S8 already contains {$}. No need to change. Done.
        
   Transition on *, inheriting the LA set:
        S4: 4.  L:  * . R       {$} 
        LA set at 4 already contains {$}. No need to change. Done.

    Transition on i, inheriting the LA set:
        S5: 5.  L:  i .         {$}
        LA set at 5 already contains {$}. No need to change. Done.


S7: 4.  L:  * R .       {= $}

    Reduce: according to rule 4 (by default)

S8: 6.  R:  L .         {= $}
    
    Reduce: according to rule 6 (by default)

S9: 2.  S:  L = R .     {$}

    Reduce: according to rule 2 (by default)

==========================================================================

Finally consider Aho's 4.42 grammar, p. 231:

    1.  S*:  S
    2.  S:   C C
    3.  C:   c C
    4.  C:   d

Starting at 1, using LA {$}

S0: 1.  S*: . S         {$}

    Add production rules from S, using LA {$}:
        2.  S: . C C    {$}
        
    Add production rules from C, using LA FIRST(C $} = {c d}
        3.  C: . c C    {c d}
        4.  C: . d      {c d}

    Resulting in:
        S0: 1.  S*: . S     {$}
            2.  S: . C C    {$}
            3.  C: . c C    {c d}
            4.  C: . d      {c d}

    Transitions on:
        S -> S1
        C -> S2
        c -> S3
        d -> S4

    Transition on S, inheriting LA:
        S1: 1.  S*: S .     {$}

    Transition on C, inheriting LA:
        S2: 2.  S: C . C    {$}

    Transition on c, inheriting LA:
        S3: 3.  C: c . C    {c d}

    Transition on d, inheriting LA:
        S4: 4.  C: d .      {c d}


S1: 1.  S*: S .     {$}

    Reduce: according to rule 1 (by default)

S2: 2.  S: C . C    {$}

    Add production rules from C, using LA FIRST($} = {$}
        3.  C: . c C    {$}
        4.  C: . d      {$}

    Resulting in:
        S2: 2.  S: C . C    {$}
            3.  C: . c C    {$}
            4.  C: . d      {$}

    Transitions on:
        C -> S5
        c -> S3
        d -> S4

    Transition on C, inheriting LA:
        S5: 2.  S: C C .    {$}

    Transition on c, inheriting LA:
        S3: 3.  C: c . C    {$}
        Add $ to LA set of S3

    Transition on d, inheriting LA:
        S4: 4.  C: d .      {c d}
        Add $ to LA set of S4

S3: 3.  C: c . C    {c d $}

    Add production rules from C, using LA FIRST($} = {c d $}
        3.  C: . c C    {c d $}
        4.  C: . d      {c d $}

    Resulting in:
        S3: 3.  C: c . C    {c d $}
            3.  C: . c C    {c d $}
            4.  C: . d      {c d $}

    Transitions on:
        C -> S6
        c -> S3
        d -> S4

    Transition on C, inheriting LA:
        S6: 3.  C: c C .    {c d $}

    Transition on c, inheriting LA:
        S3: 3.  C: c . C    {c d $}     Already defined in this configuration

    Transition on d, inheriting LA:
        S4: 3.  C: d .      {c d $}     Already defined in this configuration

S4: 4.  C: d .      {c d $}
    
    Reduce: according to rule 4 (by default)
    
S5: 2.  S: C C .    {$}

    Reduce: according to rule 2 (by default)

S6: 3.  C: c C .    {c d $}

    Reduce: according to rule 3 (by default)

=============================================================================

The algorithm implementing the above LA propagation is implemented in various
functions in the class State, starting in state/propagatela.cc 


