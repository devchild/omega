The information in this file is closely related to what's happening in
state/define.cc. Refer to define.cc for the implementation of the process
described below. All functions mentioned below are defined by the class State.


Defining states proceeds as follows:

 0. The initial state is constructed. It contains the augmented grammar's
    production rule. This part is realized by the static member

         initialState();

 1. From the state's kernel item(s) all implied rules are added as
    additional state items. This results in a vector of (kernel/non-kernel)
    items, as well as per item the numbers of the items that are affected
    by this item. This information is used later on to propagate the
    LA's. This part is realized by the member
         
         setItems()

    This fills the StateItem::Vector vector. A StateItem contains

        1. an item (containing a production rule, dot position, and LA set)
        2. a LA-enlarged flag, raised when an item's LA set is enlarged
        3. a size_t vector of indices of `dependent' items, indicating which
           items have LA sets that depend on the current item
           (StateItem::d_child).
        4. The size_t field `next' holds the index in d_nextVector,
           allowing quick access of the d_nextVector element defining the
           state having the current item as its kernel. A next value 'npos'
           indicates that the item does not belong to a next-kernel.

    E.g., 

    StateItem:
    ---------------------------------------------------------------
    item        LA-enlarged LA-set  dependent   next    next
                                    stateitems  state   LA-enlarged
    ---------------------------------------------------------------
    S* -> . S,  false,      EOF,    (1, 2)      0       true/false
    ...
    ---------------------------------------------------------------

    Also, State::d_nextVector vector is filled.

    A Next element contains

         0. The symbol on which the transition takes place
         1. The number of the next state
         2. The indices of the StateItem::Vector defining the next
                state's kernel 
     
     E.g., 

     Next:
     -------------------------------
     On          next    next kernel
     Symbol      state   from items
     -------------------------------
     S           ?       (0, 1)
     ...
     -------------------------------

    Previously, nextOnSymbol() was called here. It simply removed the
    production rules where dot appeared at the rule's end, since they will not
    become part of the next state's kernels.
     
    Empty production rules don't require special handling as they won't appear
    in the Next table, since there's no transition on them. Thus, the
    previously mentioned nextOnSymbol() function is now no longer required.

    Next, from these facilities all states are constructed. LA propagation is
    performed after the state construction since LA propagation is an
    inherently recursive process, and state construction isn't. State
    construction takes place (in the while loop in State::define.cc following
    the initial state construction).

 2. Following the state construction the lookaheads (LAs) will be propagated
    over the items in the current state. This is where previous bisonc++
    versions erred. LAs are distributed over and determined for each
    individual item, and are then inherited by the next states. Also, LAs can
    be determined during the construction of a state, instead of during a
    separate cycle. LAs are propagated from the initial state over the
    dependent StateItems. Lookahead propagation is performed by the member
                 
         propagateLA()

 3. Then, from the Next::Vector constructed at (1) the next states
    are constructed. This is realized by the member

         constructNext()

    A next state is only constructed if it wasn't constructed yet. For a new
    state, the construct() member is called. Construct() calls setItems()
    and propagateLA(). Otherwise, propagateLA will also be called for all
    states having kernels whose next LA-enlarged flag is set.

 4. Once all states have been constructed, conflicts are located and
    solved. If a state contains conflict, they are resolved and
    information about these conflicts is stored in an SRConflict::Vector
    and/or RRConflict::Vector. Conflicts are identified and resolved by the
    member: 

         State::checkConflicts();

5.  S/R conflicts are handled by the d_srConflict object. This object received
    at construction time a context consisting of the state's d_itemVector and
    d_nextVector as well as d_reducible containing all indices of reducible
    items. Each of these indices is the index of a reducible item which is,
    together with a context consisting of the state's d_itemVector and
    d_nextVector, passed to Next::checkShiftReduceConflict(), which solves the
    observed shift-reduce conflicts. 

    Here is how this is done:

    Assume a state's itemVector holds the following StateItems:

        0:    [P11 3] expression -> expression '-' expression  .   
                        { EOLN '+' '-' '*' '/' ')' }  0, 1, () -1 
        1:    [P10 1] expression -> expression  . '+' expression   
                        { EOLN '+' '-' '*' '/' ')' }  0, 0, () 0 
        2:    [P11 1] expression -> expression  . '-' expression   
                        { EOLN '+' '-' '*' '/' ')' }  0, 0, () 1 
        3:    [P12 1] expression -> expression  . '*' expression   
                        { EOLN '+' '-' '*' '/' ')' }  0, 0, () 2 
        4:    [P13 1] expression -> expression  . '/' expression   
                        { EOLN '+' '-' '*' '/' ')' }  0, 0, () 3 
    
    and the associated nextVector is:
    
        0:    On '+' to state 15 with (1 )
        1:    On '-' to state 16 with (2 )
        2:    On '*' to state 17 with (3 )
        3:    On '/' to state 18 with (4 )
    
    
    Conflicts are inspected for all reducible items. Here the reducible item
    is the item having index 0. 

    Inspection involves (but see below for an extension of this process when
    the LHS of a reducible item differs from the LHS of a non-reducible item):
    
        1. The nextVector's symbols are searched for in the LA set of the
           reduction item (so, subsequently '+', '-', '*' and '/' are searched
           for in the LA set of itemVector[0]).
        2. In this case, all are found and depending on the token's priority
           and the rule's priority either a shift or a reduce is selected. 
     
     Production rules received their priority setting either explicitly (using
     %prec) or from their first terminal token. See also
     rules/updateprecedences.cc
    

    What happens if neither occurs? In a rule like 'expr: term' there is no
    first terminal token and there is no %prec being used. 
    In these cases the rule is removed, by default using a shift instead of a
    reduce (until 4.00.00 this was handled incorrectly by giving the reduction
    rule the highest precedence, using a reduce rather than a shift) 
    The problem with rules without precedence was originally brought to my
    attention by Ramanand Mandayam.

    Different LHS elements of items:

    As pointed out by Ramanand Mandayam, S/R conflicts may be observed when
    reducible rules merely consist of non-terminals. Here is an example:
    
    %left  '*'                                
    %token ID
    %%
    expr: 
        term 
    ;
    term:
        term '*' primary
    | 
        ID
    ;
    primary:
        '-' expr
    | 
        ID
    ;
    
    This grammar contains the following state
    
    State 2:
    0: [P1 1] expr -> term  .   { <EOF> }  1, () -1
    1: [P2 1] term -> term  . '*' primary   { '*' <EOF> }  0, () 0
      0: On '*' to state 4 with (1 )
      Reduce item(s): 0 
    
    Here, item 0 reduces to N 'expr' and item 1 requires a shift in a
    production rule of the N 'term'.
    
    In these cases the rule 'expr -> term .' has no precedence that can be
    derived from either %prec or an initial terminal. Such reductions
    automatically receive the highest possible precedence and 'reduce' is
    used, rather than 'shift'. Since there is no explicit basis for this
    choice the choice between shift and reduce is flagged as a conflict.


