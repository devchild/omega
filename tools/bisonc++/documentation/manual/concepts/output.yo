When you run b(), you give it a b() grammar file as input. The
output, however, defines a bf(C++) em(class), in which several em(members)
have already been defined. Therefore, the em(output) of b() consists of
em(header files) and a bf(C++) source file, defining a member (tt(parse()))
that parses the language described by the grammar. The class and its
implementation is called a b() em(parser class). Keep in mind that the
B() utility and the b() parser class are two distinct pieces of
software: the b() utility is a program whose output is the b()
parser class that becomes part of your program. 

More specifically, b() generates the following files from a b()
grammar file:
    itemization(
    it() A em(baseclass header), which can be included by em(lexical scanners)
(see below), primarily defining the em(lexical tokens) that the parser expects
the lexical scanner to return;
    it() A em(class header), defining the b() parser class interface;
    it() An em(implementation header), which is used to declare all entities
which are em(only) used by b()'s parser class em(implementation) (and not
required by the remaining parts of your program);
    it() The em(parsing member), actually performing the parsing of a
provided input according to the rules of the defined b() grammar (that
you, as b()'s user, defined).
    )

The job of the b() parsing member is to group tokens into groupings
according to the grammar rules--for example, to build identifiers and
operators into expressions. As it does this, it runs the actions for the
grammar rules it uses.

In bf(C++) the tokens should be produced by an object called the em(lexical
analyzer) or em(lexical scanner) that you must supply in some fashion (such as
by writing it in bf(C++)). The b() parsing member requests the next token from
the lexical analyzer each time it wants a new token. The parser itself doesn't
know what is "inside" the tokens (though their semantic values may reflect
this). Typically the lexical analyzer makes the tokens by parsing characters
of text, but b() does not depend on this. See section ref(LEX).

The b() parsing function is bf(C++) code defining a member function named
tt(parse()) which implements that grammar. This parsing function nor the
parser object for which it is called does make a complete bf(C++) program: you
must supply some additional details. One `detail' to be supplied is is the
lexical analyzer. The parser class itself declares several more members which
must be defined when used. One of these additional members is an
error-reporting function which the parser calls to report an error. Simple
default, yet sensible, implementations for these additional members may be
generated by b(). Having constructed a parser class and a lexical scanner
class, em(objects) of these classes must be defined in a complete bf(C++)
program. Usually such objects are defined in a function called tt(main()); you
have to provide this, and arrange for it to call the parser's tt(parse())
function, or the parser will never run. See chapter ref(INTERFACE).

Note that, different from conventions used by Bison and Bison++, there is no
special name convention requirement anymore imposed by b(). In
particular, there is em(no) need to begin all variable and function names used
in the b() parser with `yy' or `YY' anymore. However, some name restrictions on
symbolic tokens exist. See section ref(IMPROPER) for details.



