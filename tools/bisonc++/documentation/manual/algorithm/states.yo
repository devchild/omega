Having determined the tt(FIRST) and tt(FOLLOW) sets, b() determines the
em(states) of the grammar. The analysis starts at the augmented grammar rule
and proceeds until all possible states have been determined. 
For this analysis the concept of the em(dot) symbol is used. The em(dot) shows
the position we are when analyzing production rules defined by a grammar.
Using the provided example grammar the analysis proceeds as follows:
    itemization(
    it() State 0: tt(start_$ -> . start)nl()
        At this point we haven't seen anything yet. The em(dot) is before the
grammar's start symbol. The above is called an em(item) and the initial set of
states is called the set of em(kernel items). In this state there's only one
kernel item. Items are indexed, so this item receives index 0. Beyond, item
indices are shown together with the items themselves. To the kernel set all
production rules of non terminals immediately following the dot are added
(repeatedly, so if new rules again show nonterminals to the right of the dot,
then their production rules are added too). These added rules define the
non-kernel set of items. Except for the augmented grammar rule's state kernel
items don't have dots at their first positions.

    From the above kernel item the following non-kernel items are derived:
        itemization(
        it() item 1: tt(start ->  . start expr)
        it() item 2: tt(start ->  . )
        )
    From the items new states are derived: each em(transition) moves the dot
one postition to the right. Once the dot has reached the end of the rule, a
em(reduction) may take place. Following a reduction a transition based on the
tt(LHS) of the reduced production rule is performed. This process is discussed
in more detail in section ref(PARSING). 

    Looking at the state's items, two actions are detected:
    itemization(
    it() On tt(start), to a state in which tt(start) has been seen (state 1)
    it() By default, reduce by the rule tt(start ->  . )
    )

    it() State 1: kernel items:
        itemization(
        it() item 0: tt(start_$ -> start  .)
        it() item 1: tt(start -> start  . expr)
        )
        Non-kernel items:
        itemization(
        it() item 2: tt(expr ->  . NR)
        it() item 3: tt(expr ->  . expr '+' expr)
        )
    This state becomes the em(accepting) state: if in this state EOF is
reached, the tt(start_$) rule has been recognized, and so the input could be
recognized by the grammar. Other transitions are possible to, though:
        itemization(
        it() On tt(expr) to state 2
        it() On NR to state 3
        )
    
    it() State 2: kernel items:
        itemization(
        it() item 0: tt(start -> start expr  .)
        it() item 1: tt(expr -> expr  . '+' expr)
        )
        No non-kernel items need to be added to this state. It has the
        following transitions:
        itemization(
        it() On tt('+') to state 4
        it() Or reduce to tt(start) according to its first item (removing
            two elements from the parser's stack).
        )

    it() State 3: kernel items:
        itemization(
        it() item 0: tt(expr -> NR  .)
        )
        In this state only one action is possible: a reduction to tt(expr)
        (removing one element from the parser's stack).


    it() State 4: kernel item:
        itemization(
        it() item 0: tt(expr -> expr '+'  . expr)
        )
        Two non-kernel items are added:
        itemization(
        it() item 1: tt(expr -> . NR)
        it() item 2: tt(expr -> . expr '+'  expr)
        )
        This state has the following transitions:
        itemization(
        it() On tt(expr) to state 5 
        it() On tt(NR) to state 3
        )
        The last action is interesting in that it returns to a previously
defined  state. That's OK, but it requires that a state is reached having
exactly the matching number of kernel items. So, if state 3 would have had yet
anoher state, a new state would have been constructed to where this state
would transit on encountering a tt(NR) token.

    it() State 5: kernel items:
        itemization(
        it() item 0: tt(expr -> expr '+' expr  .)
        it() item 1: tt(expr -> expr . '+' expr)
        )
        In this state two actions are possible:
        itemization(
        it() On tt('+') to state 4
        it() Or reduce to tt(expr) according to its first item (removing three
            elements from the parser's stack).
        )

        With the current grammar it turns out (and the reason why this is so
        will be discussed in the next section) that the first action will
        never take place: in this state there will always be a reduction.
    )
