
    The following public members and types are available to users of the
parser classes generated by bic() (parser class-name prefixes (e.g.,
tt(Parser::)) prefixes are silently implied):
    itemization(
    it() bf(LTYPE__):nl() 
           The parser's location type (user-definable). Available only when
            either tt(%lsp-needed, %ltype) or tt(%locationstruct) has been
            declared. 
    it() bf(STYPE__):nl()
            The parser's stack-type (user-definable), defaults to bf(int).
    it() bf(Tokens__):nl()
           The enumeration type of all the symbolic tokens defined in the
            grammar file (i.e., bic()'s input file). The scanner should be
            prepared to return these symbolic tokens. Note that, since the
            symbolic tokens are defined in the parser's class and not in the
            scanner's class, the lexical scanner must prefix the parser's
            class name to the symbolic token names when they are
            returned. E.g., tt(return Parser::IDENT) should be used rather
            than tt(return IDENT).
    it() bf(int parse()):nl()
           The parser's parsing member function. It returns 0 when parsing was
            successfully completed; 1 if errors were encountered while parsing
            the input.
    it() bf(void setDebug(bool mode)):nl()
       This member can be used to activate or deactivate the debug-code
        compiled into the parsing function. It is always defined but is only
        operational if the tt(%debug) directive or tt(--debug) option was
        specified. When debugging code has been compiled into the parsing
        function, it is em(not) active by default. To activate the debugging
        code, use tt(setDebug(true)).

       This member can be used to activate or deactivate the debug-code
        compiled into the parsing function. It is available but has no
        effect if no debug code has been compiled into the parsing
        function. When debugging code has been compiled into the parsing
        function, it is active by default, but debug-code is suppressed by
        calling tt(setDebug(false)).
    )

When the tt(%polymorphic) directive is used:
    itemization(
    it() bf(Meta__):nl()
           Templates and classes that are required for implementing the
            polymorphic semantic values are all declared in the tt(Meta__)
            namespace. The tt(Meta__) namespace itself is nested under the
            namespace that may have been declared by the tt(%namespace)
            directive.
    
    it() bf(Tag__):nl()
           The (strongly typed) tt(enum class Tag__) contains all the
            tag-identifiers specified by the tt(%polymorphic) directive. It is
            declared outside of the Parser's class, but within the namespace
            that may have been declared by the tt(%namespace) directive.
    )


